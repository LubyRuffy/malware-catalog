import re
from makeyaml import yaml_structure
import yaml

# log to read
# TODO: finish writing rules - generate a new, complete output file to read from
yara_output = "input/yara.txt"

# predefined exploits
exploit_list = "input/exploits.txt"
#predefined variant names - mirai and qbot
mirai_list = "input/mirai.txt"
qbot_list = "input/qbot.txt"

# TODO: write to this file
# TODO: convert directly to json from here
output_file = "output/mirai.yaml"

with open(mirai_list, "r") as mirai_variants:
	 mirai = mirai_variants.read().splitlines()

with open(qbot_list, "r") as qbot_variants:
	qbot = qbot_variants.read().splitlines()

with open(exploit_list, "r") as all_exploits:
	exploits = all_exploits.read().splitlines()



bot_types = {"mirai": mirai, "qbot": qbot}

# i/o setup
with open(yara_output, "r") as yara_lines:
	# produces a list of lines of input file
	exploit_occurrences = yara_lines.read().splitlines()

	exploit_used_by = {}
	variant_exploits = {}	

# variants-by-exploit and exploits-by-variant listing generation #######################################

	# prepare input -
	# per line, grab exploit name and variant name by dismantling file path
	for occurrence in exploit_occurrences:

		exploit = occurrence.split()[0] # first thing on each line is the exploit name (matched rule)

		# take advantage of the "//" yara prints out in the path to consistently split
		# regex works too; this was simpler, reimplement it later for more varied usage

		trimmed_path = occurrence.split("//")[1] 	 # "Bot.Variant/..." 
		variant_folder = trimmed_path.split(".")[1]  # "Variant/..."
		variant_name = variant_folder.split("/")[0]  # "Variant" = isolated, ok

		# Each line can be catalogued by its exploit and the variants that use it:
		if exploit in exploits:
			# Make a new list for this exploit if there isn't one established yet. 
			if exploit not in exploit_used_by:
				exploit_used_by[exploit] = []

			# If unique and valid, add this variant name to the current exploit's list.
			if variant_name not in exploit_used_by[exploit]:
				if variant_name in mirai or variant_name in qbot:
					exploit_used_by[exploit].append(variant_name)
			exploit_used_by[exploit].sort() # alphabetize		

		# Each line should also be catalogued by (valid) variant, and the exploits each one uses:
		if variant_name in mirai or variant_name in qbot:
			# If the variant doesn't have a list of exploits yet, establish one
			if variant_name not in variant_exploits:
				variant_exploits[variant_name] = []
			# Exploit needs to be valid too:
			if exploit in exploits:
				# and not already in this variant's list:
				if exploit not in variant_exploits[variant_name]:
					variant_exploits[variant_name].append(exploit)
			variant_exploits[variant_name].sort() # alphabetize


# yaml field population ##############################################################################
	# the actual generated yaml for each bot variant, by type:
	variants_by_bot_type = yaml_structure(bot_types)

	# TODO: Make this into a function
	# Find all the empty exploits fields and pass them their appropriate lists
	for bot_type in variants_by_bot_type:
		# just a little nickname
		variant_names = variants_by_bot_type[bot_type]

		# List of all the variant names catalogued under the current bot type
		for variant_name in variant_names.keys():
			if variant_name in variant_exploits: # Copy the list of exploits from this variant's existing list over to the bulk yaml structure
				this_variant_exploits = variant_names[variant_name]["exploits"] = variant_exploits[variant_name]



######################################################################################################
# reading from all_formatted.yml (modified version of unified_exploits)
# TODO: individual files - see notes

# TODO: After gathering all the fields from exploits, also go through the fields of the variant itself
# and account for those in the list.
# TODO: Real fields in the variant yaml files lol

# Populate a data structure for conversion to YAML/JSON with desired variant name + fields relevant to the variant.

def load_exploits(variant, specific_field=False,compiled=False):

	if variant in mirai or variant in qbot:	
		if compiled:
			cumulative_fields = {variant: {}}
		else:
			loaded_exploits = {variant: {}}

		with open("input/all_formatted.yml", "r") as all_exploits:
			exploit_entries = yaml.load(all_exploits)


			for key in exploit_entries:
				loaded = exploit_entries[key]

				for entry in loaded:
					if "exploit" in entry and entry["exploit"] in variant_exploits[variant]: # Parse this entry's exploit if it's in the list.

						if compiled:
							# Cumulative lists for each field irrespective of exploit associations
							element_list = []	
							# These fields aren't really helpful if not looking at specific exploits.
							# Other exploit-specific fields are being left in because their details are still of use for the big picture

							field_exclusions = ["exploit", "used_by", "notes"]	
							# Do not distinguish by exploit. Simply compile all fields. keys: field names, values: compiled list
							for item in entry:										
								if item not in field_exclusions:

								# if specific_field is given, test for whether this item is from the correct field before bothering to test for its
								# existence as a key in the data structure - fields besides specific_field should be ignored

									if not specific_field or (specific_field and (item == specific_field)):

										# Set up key 
										if item not in cumulative_fields[variant]: # if the structure doesnt yet have this item set up as a key, do it
											cumulative_fields[variant][item] = [] # empty							

										# TODO: Dict handling (uris uses them)
					
										# Handling nested lists
										if isinstance(entry[item], list):
											# Add length-1 nonempty lists as individual element
											if len(entry[item]) == 1 and entry[item][0]:

												if entry[item] not in element_list:
													if entry[item] not in cumulative_fields[variant][item]:
														element_list.append(entry[item])
											else:
												for element in entry[item]:
													if element and element not in element_list:
														if element not in cumulative_fields[variant][item]:
															element_list.append(element)

											# Append each item in element_list to cumulative_fields[variant][item] list.
											for element in element_list:
												if element not in cumulative_fields[variant][item]:
													cumulative_fields[variant][item].append(element)
											element_list = []

										elif entry[item]: # Regular/individual items. If not already captured, enter it in
											if not item in cumulative_fields[variant]:
												cumulative_fields[variant][item] = []
											if entry[item] not in cumulative_fields[variant][item]:
												cumulative_fields[variant][item].append(entry[item])

						else:
							# If this exploit isnt loaded in as a key yet, set it up as a dict
							if entry["exploit"] not in loaded_exploits[variant]:
								this_exploit = entry["exploit"]
								loaded_exploits[variant][this_exploit] = {}
							for item in entry:
								if item != "exploit": # for the rest of the fields,
									if this_exploit in loaded_exploits[variant]: # if this exploit is set up as a key, add its fields beneath it.
										
										if specific_field: # Allows you to specify only a single field to retrieve from each exploit.
											if item == specific_field:
												loaded_exploits[variant][this_exploit][item] = entry[item]
										else: # General/non-specific case. All fields added.
											loaded_exploits[variant][this_exploit][item] = entry[item]

				if compiled:
					return(cumulative_fields)
				else:
					return(loaded_exploits)
				

# Helper functions

# Specific_field always does the same thing. If it's true, input is limited to the provied field. Could allow list of fields as input.
def variant_fields(variant,specific_field=False):
	return load_exploits(variant, specific_field, True)


def variant_all_exploits(variant,specific_field=False):
	return load_exploits(variant, specific_field, False)

counter = 0
for v in mirai:
	if counter < 10:
		print(yaml.dump(variant_all_exploits(v)))
		counter = counter + 1
